diff -up nfs-utils-1.2.3/support/nfs/conffile.c.save nfs-utils-1.2.3/support/nfs/conffile.c
--- nfs-utils-1.2.3/support/nfs/conffile.c.save	2013-10-09 14:38:19.000000000 -0400
+++ nfs-utils-1.2.3/support/nfs/conffile.c	2013-10-09 14:38:55.000000000 -0400
@@ -255,13 +255,14 @@ conf_parse_line(int trans, char *line, s
 			val++, j++;
 		if (*val)
 			i = j;
-		section = malloc(i);
+		section = malloc(i+1);
 		if (!section) {
 			xlog_warn("conf_parse_line: %d: malloc (%lu) failed", ln,
 						(unsigned long)i);
 			return;
 		}
 		strncpy(section, line, i);
+		section[i] = '\0';
 
 		if (arg) 
 			free(arg);
diff -up nfs-utils-1.2.3/utils/mount/configfile.c.save nfs-utils-1.2.3/utils/mount/configfile.c
--- nfs-utils-1.2.3/utils/mount/configfile.c.save	2013-10-09 14:38:28.000000000 -0400
+++ nfs-utils-1.2.3/utils/mount/configfile.c	2013-10-09 14:39:19.000000000 -0400
@@ -73,6 +73,8 @@ struct mnt_alias {
 };
 int mnt_alias_sz = (sizeof(mnt_alias_tab)/sizeof(mnt_alias_tab[0]));
 
+static int strict;
+
 /*
  * See if the option is an alias, if so return the 
  * real mount option along with the argument type.
@@ -162,6 +164,20 @@ add_entry(char *opt)
 	SLIST_INSERT_HEAD(&head, entry, entries);
 }
 /*
+ * Check the alias list to see if the given 
+ * opt is a alias
+ */
+char *is_alias(char *opt)
+{
+	int i;
+
+	for (i=0; i < mnt_alias_sz; i++) {
+		if (strcasecmp(opt, mnt_alias_tab[i].alias) == 0)
+			return mnt_alias_tab[i].opt; 
+	}
+	return NULL;
+}
+/*
  * See if the given entry exists if the link list,
  * if so return that entry
  */
@@ -169,10 +185,31 @@ inline static 
 char *lookup_entry(char *opt)
 {
 	struct entry *entry;
+	char *alias = is_alias(opt);
+	char *ptr;
 
 	SLIST_FOREACH(entry, &head, entries) {
+		/*
+		 * Only check the left side or options that use '='
+		 */
+		if ((ptr = strchr(entry->opt, '=')) != 0) {
+			int len = (int) (ptr - entry->opt);
+
+			if (strncasecmp(entry->opt, opt, len) == 0)
+				return opt;
+		}
 		if (strcasecmp(entry->opt, opt) == 0)
 			return opt;
+		if (alias && strcasecmp(entry->opt, alias) == 0)
+			return opt;
+		if (alias && strcasecmp(alias, "fg") == 0) {
+			if (strcasecmp(entry->opt, "bg") == 0)
+				return opt;
+		}
+		if (alias && strcasecmp(alias, "bg") == 0) {
+			if (strcasecmp(entry->opt, "fg") == 0)
+				return opt;
+		}
 	}
 	return NULL;
 }
@@ -310,7 +347,15 @@ conf_parse_mntopts(char *section, char *
 		if (strcasecmp(value, "false") == 0) {
 			if (argtype != MNT_NOARG)
 				snprintf(buf, BUFSIZ, "no%s", field);
+			else if (strcasecmp(field, "bg") == 0)
+				snprintf(buf, BUFSIZ, "fg");
+			else if (strcasecmp(field, "fg") == 0)
+				snprintf(buf, BUFSIZ, "bg");
+			else if (strcasecmp(field, "sloppy") == 0)
+				strict = 1;
 		} else if (strcasecmp(value, "true") == 0) {
+			if ((strcasecmp(field, "sloppy") == 0) && strict)
+				continue;
 			snprintf(buf, BUFSIZ, "%s", field);
 		} else {
 			nvalue = strdup(value);
@@ -345,6 +390,7 @@ char *conf_get_mntopts(char *spec, char 
 	char *ptr, *server, *config_opts;
 	int optlen = 0;
 
+	strict = 0;
 	SLIST_INIT(&head);
 	list_size = 0;
 	/*
