diff -up nfs-utils-1.2.3/utils/exportfs/exports.man.orig nfs-utils-1.2.3/utils/exportfs/exports.man
--- nfs-utils-1.2.3/utils/exportfs/exports.man.orig	2016-07-07 13:15:11.950930982 -0400
+++ nfs-utils-1.2.3/utils/exportfs/exports.man	2016-07-07 13:15:39.819490335 -0400
@@ -208,16 +208,46 @@ This option can be very useful in some s
 used with due care, and only after confirming that the client system
 copes with the situation effectively.
 
-The option can be explicitly disabled with
+The option can be explicitly disabled for NFSv2 and NFSv3 with
 .IR hide .
+
+This option is not relevant when NFSv4 is use.  NFSv4 never hides
+subordinate filesystems.  Any filesystem that is exported will be
+visible where expected when using NFSv4.
 .TP
-.IR crossmnt
+.I crossmnt
 This option is similar to
 .I nohide
-but it makes it possible for clients to move from the filesystem marked
-with crossmnt to exported filesystems mounted on it.  Thus when a child
-filesystem "B" is mounted on a parent "A", setting crossmnt on "A" has
-the same effect as setting "nohide" on B.
+but it makes it possible for clients to access all filesystems mounted
+on a filesystem marked with
+.IR crossmnt .
+Thus when a child filesystem "B" is mounted on a parent "A", setting
+crossmnt on "A" has a similar effect to setting "nohide" on B.
+
+With
+.I nohide
+the child filesystem needs to be explicitly exported.  With
+.I crossmnt
+it need not.  If a child of a
+.I crossmnt
+file is not explicitly exported, then it will be implicitly exported
+with the same export options as the parent, except for
+.IR fsid= .
+This makes it impossible to
+.B not
+export a child of a
+.I crossmnt
+filesystem.  If some but not all subordinate filesystems of a parent
+are to be exported, then they must be explicitly exported and the
+parent should not have
+.I crossmnt
+set.
+
+The
+.I nocrossmnt
+option can explictly disable
+.I crossmnt
+if it was previously set.  This is rarely useful.
 .TP
 .IR no_subtree_check
 This option disables subtree checking, which has mild security
diff -up nfs-utils-1.2.3/utils/mountd/cache.c.orig nfs-utils-1.2.3/utils/mountd/cache.c
--- nfs-utils-1.2.3/utils/mountd/cache.c.orig	2016-07-07 13:15:12.008932141 -0400
+++ nfs-utils-1.2.3/utils/mountd/cache.c	2016-07-07 13:19:06.136629543 -0400
@@ -355,7 +355,7 @@ static char *next_mnt(void **v, char *p)
 		*v = f;
 	} else
 		f = *v;
-	while ((me = getmntent(f)) != NULL &&
+	while ((me = getmntent(f)) != NULL && l > 1 &&
 	       (strncmp(me->mnt_dir, p, l) != 0 ||
 		me->mnt_dir[l] != '/'))
 		;
@@ -381,15 +381,44 @@ static struct addrinfo *lookup_client_ad
 	freeaddrinfo(tmp);
 	return ret;
 }
-/* True iff e1 is a child of e2 and e2 has crossmnt set: */
+static int is_subdirectory(char *child, char *parent)
+{
+	/* Check is child is strictly a subdirectory of
+	 * parent or a more distant descendant.
+	 */
+	size_t l = strlen(parent);
+
+	if (strcmp(parent, "/") == 0 && child[1] != 0)
+		return 1;
+
+	return (strncmp(child, parent, l) == 0 && child[l] == '/');
+}
+
+static int path_matches(nfs_export *exp, char *path)
+{
+	/* Does the path match the export?  I.e. is it an
+	 * exact match, or does the export have CROSSMOUNT, and path
+	 * is a descendant?
+	 */
+	return strcmp(path, exp->m_export.e_path) == 0
+		|| ((exp->m_export.e_flags & NFSEXP_CROSSMOUNT)
+		    && is_subdirectory(path, exp->m_export.e_path));
+
+}
+
+static int
+export_matches(nfs_export *exp, char *dom, char *path, struct addrinfo *ai)
+{
+	return path_matches(exp, path) && client_matches(exp, dom, ai);
+}
+
+/* True iff e1 is a child of e2 (or descendant) and e2 has crossmnt set: */
 static bool subexport(struct exportent *e1, struct exportent *e2)
 {
 	char *p1 = e1->e_path, *p2 = e2->e_path;
-	int l2 = strlen(p2);
 
 	return e2->e_flags & NFSEXP_CROSSMOUNT
-	       && strncmp(p1, p2, l2) == 0
-	       && p1[l2] == '/';
+		&& is_subdirectory(p1, p2);
 }
 
 struct parsed_fsid {
@@ -523,18 +552,17 @@ static bool match_fsid(struct parsed_fsi
 		if (!is_mountpoint(path))
 			return false;
 	check_uuid:
-		if (exp->m_export.e_uuid)
+		if (exp->m_export.e_uuid) {
 			get_uuid(exp->m_export.e_uuid, parsed->uuidlen, u);
+			if (memcmp(u, parsed->fhuuid, parsed->uuidlen) == 0)
+				return true;
+		}
 		else
 			for (type = 0;
 			     uuid_by_path(path, type, parsed->uuidlen, u);
 			     type++)
 				if (memcmp(u, parsed->fhuuid, parsed->uuidlen) == 0)
 					return true;
-
-		if (memcmp(u, parsed->fhuuid, parsed->uuidlen) != 0)
-			return false;
-		return true;
 	}
 	/* Well, unreachable, actually: */
 	return false;
@@ -779,27 +807,6 @@ static int dump_to_cache(FILE *f, char *
 	return qword_eol(f);
 }
 
-static int is_subdirectory(char *child, char *parent)
-{
-	int l = strlen(parent);
-
-	return strcmp(child, parent) == 0
-		|| (strncmp(child, parent, l) == 0 && child[l] == '/');
-}
-
-static int path_matches(nfs_export *exp, char *path)
-{
-	if (exp->m_export.e_flags & NFSEXP_CROSSMOUNT)
-		return is_subdirectory(path, exp->m_export.e_path);
-	return strcmp(path, exp->m_export.e_path) == 0;
-}
-
-static int
-export_matches(nfs_export *exp, char *dom, char *path, struct addrinfo *ai)
-{
-	return path_matches(exp, path) && client_matches(exp, dom, ai);
-}
-
 static nfs_export *
 lookup_export(char *dom, char *path, struct addrinfo *ai)
 {
