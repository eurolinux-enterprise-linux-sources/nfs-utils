commit 710a492fda68092a02d6360d7a185f6a4dcaea85
Author: NeilBrown <neilb@suse.de>
Date:   Thu Feb 26 14:10:35 2015 -0500

    exports.man: improve documentation of 'nohide' and 'crossmnt'
    
    - note that 'nohide' is irrelevant for NFSv4
    - note that children on a 'crossmnt' filesystem cannot be unexported
    - note that 'nocrossmnt' is a valid option, but probably not useful.
    
    Signed-off-by: NeilBrown <neilb@suse.de>
    Signed-off-by: Steve Dickson <steved@redhat.com>

diff --git a/utils/exportfs/exports.man b/utils/exportfs/exports.man
index 59358e6..9309246 100644
--- a/utils/exportfs/exports.man
+++ b/utils/exportfs/exports.man
@@ -218,16 +218,46 @@ This option can be very useful in some situations, but it should be
 used with due care, and only after confirming that the client system
 copes with the situation effectively.
 
-The option can be explicitly disabled with
+The option can be explicitly disabled for NFSv2 and NFSv3 with
 .IR hide .
+
+This option is not relevant when NFSv4 is use.  NFSv4 never hides
+subordinate filesystems.  Any filesystem that is exported will be
+visible where expected when using NFSv4.
 .TP
-.IR crossmnt
+.I crossmnt
 This option is similar to
 .I nohide
-but it makes it possible for clients to move from the filesystem marked
-with crossmnt to exported filesystems mounted on it.  Thus when a child
-filesystem "B" is mounted on a parent "A", setting crossmnt on "A" has
-the same effect as setting "nohide" on B.
+but it makes it possible for clients to access all filesystems mounted
+on a filesystem marked with
+.IR crossmnt .
+Thus when a child filesystem "B" is mounted on a parent "A", setting
+crossmnt on "A" has a similar effect to setting "nohide" on B.
+
+With
+.I nohide
+the child filesystem needs to be explicitly exported.  With
+.I crossmnt
+it need not.  If a child of a
+.I crossmnt
+file is not explicitly exported, then it will be implicitly exported
+with the same export options as the parent, except for
+.IR fsid= .
+This makes it impossible to
+.B not
+export a child of a
+.I crossmnt
+filesystem.  If some but not all subordinate filesystems of a parent
+are to be exported, then they must be explicitly exported and the
+parent should not have
+.I crossmnt
+set.
+
+The
+.I nocrossmnt
+option can explictly disable
+.I crossmnt
+if it was previously set.  This is rarely useful.
 .TP
 .IR no_subtree_check
 This option disables subtree checking, which has mild security

commit b7341b19d62481504f1820414159009535d37809
Author: NeilBrown <neilb@suse.de>
Date:   Wed Feb 25 16:47:56 2015 -0500

    mountd: fix next_mnt handling for "/"
    
    If the (exported) path passed to next_mnt() is simply "/", next_mnt()
    will not report any children, as none start with "/" followed by a '/'.
    So make a special case for strlen(p)==1.  In that case, return all
    children.
    
    This gives correct handling if only "/" is exported.
    
    Signed-off-by: NeilBrown <neilb@suse.de>
    Signed-off-by: Steve Dickson <steved@redhat.com>

diff --git a/utils/mountd/cache.c b/utils/mountd/cache.c
index 1430aee..23af4a9 100644
--- a/utils/mountd/cache.c
+++ b/utils/mountd/cache.c
@@ -365,7 +365,7 @@ static char *next_mnt(void **v, char *p)
 		*v = f;
 	} else
 		f = *v;
-	while ((me = getmntent(f)) != NULL &&
+	while ((me = getmntent(f)) != NULL && l > 1 &&
 	       (strncmp(me->mnt_dir, p, l) != 0 ||
 		me->mnt_dir[l] != '/'))
 		;

commit 7e27d4a542bf97e0ddc1036010e1b2d218a01c2b
Author: Vivek Trivedi <t.vivek@samsung.com>
Date:   Wed Sep 16 11:14:03 2015 -0400

    mountd: fix mount issue due to comparison with uninitialized uuid
    
    Fix mount issue due to comparison of uninitialized variable
    u(uuid) with parsed->fhuuid when uuid_by_path return 0.
    
    /tmp/usb
    192.168.1.0/16(ro,no_root_squash,no_subtree_check,fsid=0)
    /tmp/usb/sda1       192.168.1.0/16(ro,no_root_squash,no_subtree_check)
    /tmp/usb/sdb1       192.168.1.0/16(ro,no_root_squash,no_subtree_check)
    
    mount -t nfs -o nolock,nfsvers=3 192.168.1.2:/tmp/usb/sda1 /tmp/sda1
    mount -t nfs -o nolock,nfsvers=3 192.168.1.2:/tmp/usb/sdb1 /tmp/sdb1
    
    results in below mountd error:
    mountd: /tmp/usb and /tmp/usb/sdb1 have same filehandle for
    192.168.1.0/16, using first
    
    when uuid_by_path returned 0, by chance, garbage value of u was same as
    parsed->fhuuid(of sdb1), and comparison of these resulted in above
    error.
    
    Signed-off-by: Vivek Trivedi <t.vivek@samsung.com>
    Reviewed-by: Amit Sahrawat <a.sahrawat@samsung.com>
    Signed-off-by: Steve Dickson <steved@redhat.com>

diff --git a/utils/mountd/cache.c b/utils/mountd/cache.c
index 9a1bb27..1430aee 100644
--- a/utils/mountd/cache.c
+++ b/utils/mountd/cache.c
@@ -547,18 +547,17 @@ static bool match_fsid(struct parsed_fsid *parsed, nfs_export *exp, char *path)
 		if (!is_mountpoint(path))
 			return false;
 	check_uuid:
-		if (exp->m_export.e_uuid)
+		if (exp->m_export.e_uuid) {
 			get_uuid(exp->m_export.e_uuid, parsed->uuidlen, u);
+			if (memcmp(u, parsed->fhuuid, parsed->uuidlen) == 0)
+				return true;
+		}
 		else
 			for (type = 0;
 			     uuid_by_path(path, type, parsed->uuidlen, u);
 			     type++)
 				if (memcmp(u, parsed->fhuuid, parsed->uuidlen) == 0)
 					return true;
-
-		if (memcmp(u, parsed->fhuuid, parsed->uuidlen) != 0)
-			return false;
-		return true;
 	}
 	/* Well, unreachable, actually: */
 	return false;
